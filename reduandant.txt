client.on('interactionCreate',  (interaction) => {
  console.log(interaction);
  interaction.reply("Why would u ping");
});

client.on('interactionCreate', (intraection)=>{
  intreaction.reply("Oh what");

});


// Set the bot's presence status
  client.user.setPresence({
      activity: { 
        name: 'misaka.worst', // Update this to your desired status message
        type: 'PLAYING' // You can change the activity type (e.g., WATCHING, LISTENING, PLAYING)
      },
      status: 'online' // You can change the status (e.g., online, idle, dnd, invisible)
  
    });



    client.on('message', async message => {
    if (message.content === '!sendEmptyMessage') {
        // Attempting to send an empty message
        try {
            const channel = await client.channels  //.fetch(channelId);
            // Check if message content is empty
            const content = 'This is a non-empty message'; // Example content
            if (content) {
                // Sending the message if content is not empty
                const sentMessage = await channel.send(content);
                console.log('Message sent successfully:', sentMessage.content);
            } else {
                console.log('Message content is empty. Not sending.');
            }
        } catch (error) {
            console.error('Error sending message:', error);
        }
    }
});






// client.on('ready', () => {
//   console.log(`Logged in as a ${client.user.tag}!`);

// });
// let status = [
//   {
//     name: 'I am Streaming',
//     type: ActivityType.Streaming,
//     // url: 'https://youtu.be/SxLcO2kodFU?si=hCnq9Cj6h7bfs0ww'
//     // url: 'https://www.youtube.com/live/jfKfPfyJRdk?si=Xs9v-m1j6F2_3H_g'
//     url: 'https://www.twitch.tv/chilledcat_music'
//   },
//   {
//     name: ' With Your Mom',
//     type: ActivityType.Playing
  
//   },
//   {
//     name: 'Over Servers',
//     type: ActivityType.Watching,
//   },
//   {
//     name: 'Perils of Misaka',
//     type: ActivityType.Listening
//   },
// ];

// client.on('ready', (c) => {
//   console.log(`âœ… ${c.user.tag} is online.`);

//   setInterval(() => {
//     let random = Math.floor(Math.random() * status.length);
//     client.user.setActivity(status[random]);
//   }, 10000);

//   // client.user.setActivity({ name: 'something', typeopt :ActivityType.Listening})

// });



// client.on("messageCreate", (message) => {
//   if (message.author.bot) return;
//   console.log(message.content);
//   // message.reply({
//         // content: "Misaka sees You"
        

//   // });
// });

// client.on('interactionCreate', (interaction) => {
//   if (!interaction.isChatInputCommand()) return;
//   console.log(interaction.commandName);

//   if (interaction.commandName === "ping") {
//     interaction.reply("Why would u ping");
//   }

//   if (interaction.commandName === "misaka") {
//     interaction.reply("Is love");
//   }

//   if (interaction.commandName === "love-finder") {
//     let opt1 = interaction.options.getString('user1_name');
//     let opt2 = interaction.options.getString('user2_name');


//     if (!opt1 || !opt2) {
//       return interaction.reply('Please provide both user names.');
//     }
//     // Array of possible replies
//     const replies = ["Yes you Got Blessing", "Hell NO", "Hell Yes", "Hapyy wedding"];

//     // Randomly select a reply from the array
//     const randomReply = replies[Math.floor(Math.random() * replies.length)];

//     interaction.reply(`The names you gave is  ${opt1}  ${opt2}. ${randomReply}`);
//   }
  
//   if (interaction.commandName === "about-me") {
//   const embed = new EmbedBuilder()
//   .setTitle('I am Inori')
//   .setDescription('I work For Funeral Parlour')
//   .setColor('Random')
//   interaction.reply({embeds: [embed]})
//   }
// });

// client.on("messageCreate", (message) => {

//   if(message.content === "inori"){
//     const embed = new EmbedBuilder()
//     .setTitle('I am Inori')
//     .setDescription('I work For Funeral Parlour')
//     .setColor('Random')
//     .setAuthor({ name: 'Invite Link', iconURL: process.env.INORITHUMB, url:process.env.BOTINVURL  })
//     .setThumbnail(process.env.INORITHUMB)
//     .setImage(process.env.INOCCGIF)
//     .setURL(process.env.BOTINVURL)
//     .setTimestamp()
// 	  .setFooter({ text: 'Made by Misaka', iconURL: process.env.INORITHUMV})
//     .addFields(
//       { name: 'Regular field title', value: 'Some value here' },
//       { name: '\u200B', value: '\u200B' },
//       { name: 'Inline field title', value: 'Some value here', inline: true },
//       { name: 'Inline field title', value: 'Some value here', inline: true },
//     )
//     .addFields({ name: 'Inline field title', value: 'Some value here', inline: true })
//     message.channel.send({embeds: [embed]})
//     }
//   });
  

  
//   client.on('interactionCreate', async (interaction) => {  

//     try 
//         {if (!interaction.isButton()) return;
//        await interaction.deferReply({ephemeral: true});

//        const role = interaction.guild.roles.cache.get(interaction.customId);
//        if(!role){
//          interaction.editReply({
//            content: "I couldn't found that role",
//          })
//          return;
//        }
             
//           const hasRole = interaction.member.roles.cache.has(role.id);
   
//           if(hasRole){
//           await interaction.member.roles.remove(role);
//           await interaction.editReply(`The  ${role} has been removed.`);
//           return; 
//          }
//           await interaction.member.roles.add(role);
//           await interaction.editReply(`The  ${role} has been Added.`);
       
//      } catch (error) {
//        console.log('')
//      }
//    });


const { REST, Routes } = require('discord.js');
const { clientIdd,guildId, token } = require('../../../config.json');

const rest = new REST().setToken(token);

rest.put(Routes.applicationCommands(clientIdd), { body: [] })
	.then(() => console.log('Successfully deleted all application commands.'))
	.catch(console.error); 

rest.put(Routes.applicationGuildCommands(clientIdd, guildId), { body: [] })
	.then(() => console.log('Successfully deleted all guild commands.'))
	.catch(console.error);

  Codes which are to be used or deleted






Button builder for poll command with action builder and button builder //
 callback: async (client, interaction) => {
      
            const question = interaction.options.getString('question');
            const options = [];
    
            // Collect options from command options
            for (let i = 1; i <= 12; i++) {
                const option = interaction.options.getString(`option${i}`);
                if (option) {
                    options.push(option.trim());
                }
            }
    
            if (options.length < 2) {
                return await interaction.reply({ content: 'Please provide at least 2 options.', ephemeral: true });
            }
    
            // Generate buttons using ButtonBuilder and ActionRowBuilder
            const components = generateButtons(options);
    
            const embed = new EmbedBuilder()
                .setColor('#ff9900')
                .setTitle('Poll')
                .setDescription(question)
                .addFields(
                    { name: 'Options', value: options.map((option, index) => `${index + 1}. ${option}`).join('\n') }
                )
                .toJSON();
    
            try {
                // Send poll embed with buttons
                const sentMessage = await interaction.reply({ content: 'Here is your poll:', embeds: [embed], components, ephemeral: true });
    
                // Await interaction with sent message
                const filter = (interaction) => interaction.message.id === sentMessage.id;
                const collector = interaction.channel.createMessageComponentCollector({ filter, time: 60000 });
    
                collector.on('collect', async (interaction) => {
                    const optionIndex = parseInt(interaction.customId.split('_')[1]) - 1;
                    if (!isNaN(optionIndex) && optionIndex >= 0 && optionIndex < options.length) {
                        await interaction.deferUpdate();
                        await interaction.message.react(getNumberEmoji(optionIndex + 1));
                    }
                });
    
                collector.on('end', async () => {
                    await sentMessage.edit({ components: [] });
                });
            } catch (error) {
                console.error('Error creating poll:', error);
                await interaction.reply({ content: 'Failed to create poll. Please try again.', ephemeral: true });
            }
        },
    };
    
    // Function to generate message buttons for options
    function generateButtons(options) {
        const rows = [];
        let currentRow = new ActionRowBuilder();

        for (let i = 0; i < options.length; i++) {
            const button = new ButtonBuilder()
                .setCustomId(`option_${i + 1}`)
                // .setLabel(options[i])
                .setLabel(`${i + 1}`)
                .setStyle(ButtonStyle.Primary);

             currentRow.addComponents(button);
    
             if (currentRow.components.length === 5 || i === options.length - 1) {
                rows.push(currentRow);
                // Reset current row for the next set of buttons
                currentRow = new ActionRowBuilder();
            }
        }
        return rows;
    }